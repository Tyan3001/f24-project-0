\documentclass[12pt,letterpaper]{ntdhw}


\usepackage{ntdmath}

\title{Project 0: Lisp Introduction and Set Operations}
\author{CSCI 561}

\rhead{Names:}

%\keytrue

\begin{document}
\pagestyle{fancyplain}

\maketitle
\thispagestyle{fancyplain}
%\clearpage

\begin{enumerate}

  \item Describe the Lisp development environment that you used for
  this project.  (\emph{Hint: The correct answer is ALIVE, SLIME, or
    similar.})

  \item What are the types of the following Lisp expressions?
  \begin{enumerate}
    \item {\tt 1} : \emph{
      An integer Literal.
    }
    \item {\tt (+ 1 2)} : \emph{
      An s-expression that evaluates to an integer (3) because it adds two integers.
    }
    \item {\tt '(+ 1 2)} : \emph{
      A quoted list with three elements that doesn't evaluate.
    }
    \item {\tt (eval '(+ 1 2))} : \emph{
      An s-expression that evaluates to integer (3) because it's evaluating a quoted list with three elements.
    }
    \item {\tt (lambda () (+ 1 2))} : \emph{
      An anonymous function that adds two integers.
    }
    \item {\tt "foo"} : \emph{
      A string literal.
    }
    \item {\tt 'bar} : \emph{
      A quoted symbol bar.
    }
  \end{enumerate}

  \item Tail Calls:
  \begin{enumerate}
    \item What is tail recursion?

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

    \item In the recursive implementation, will {\tt fold-left} or
    {\tt fold-right} be more memory-efficient?  Why?

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}
  \end{enumerate}

  \item Lisp and Python represent code differently.

  \begin{enumerate}
    \item Contrast the representations of Lisp code and Python code.

    \begin{emph}
      Answer: Lisp represents code as lists, allowing it to treat code as data, while Python represents code as text that needs to be parsed before execution.
    \end{emph}

    \item How does Python's {\tt eval()} differ from the approach of Lisp?

    \begin{emph}
      Answer:  Pythonâ€™s {\tt eval()} evaluates a string of code and it requires parsing, whereas Lisp can directly evaluate lists, since its code is inherently structured as data.
    \end{emph}
  \end{enumerate}

  \item GCC supports an extension to the C language that allows
  local/nested functions (functions contained in other functions).  A
  GCC local function can access local variables from its parent
  function.
  \begin{enumerate}
    \item What problems would arise if you return a function pointer
    to a GCC local function? \emph{(Hint: ``Funarg problem'')}

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

    \item How does Lisp handle this problem?

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

  \end{enumerate}

  \item Test the performance of your implementation of
    \texttt{merge-sort}.
    \begin{enumerate}

    \item Plot the running time of both your \texttt{merge-sort}
      implementation and the builtin Lisp \texttt{sort} function for
      increasing input sizes.  Include enough data points to
      demonstrate the empirical asymptotic running time.

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

  \item What asymptotic running time did you expect for
    \texttt{merge-sort} and the builtin Lisp \texttt{sort} function, and
    what running time did you observe?  Explain any differences.

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

    \end{enumerate}

  \item Newton's method is a powerful technique for finding roots of real-valued functions. Given a function \( p(x) \), Newton's method iteratively computes the next approximation \( x_{n+1} \) of the root using its derivative, \( p'(x) \), as follows:

    \[
    x_{n+1} = x_n - \frac{p(x_n)}{p'(x_n)}
    \]

    For this question, you will use your implementation of {\tt find-fixpoint} to find roots of polynomials via Newton's method.
  \begin{enumerate}
    \item Determine \( f(x) \):

    Given a polynomial \( p(x) \) and its derivative \( p'(x) \), determine the function \( f(x) \) that should be used in the {\tt find-fixpoint} function. Write down the expression for \( f(x) \).

    \begin{emph}
      Answer: % Derive and write \( f(x) \) here.
    \end{emph}

    \item Implement and Test:

    Implement the function \( f(x) \) you derived, and use {\tt find-fixpoint} to find the roots of the following polynomials using Newton's method:
    \begin{enumerate}
      \item \( p(x) = x^2 - 2 \)
      \item \( p(x) = x^3 - x - 2 \)
      \item \( p(x) = x^3 - 6x^2 + 11x - 6 \) (roots are 1, 2, 3)
    \end{enumerate}

    For each polynomial, choose an initial guess and use a precision of \( 0.001 \). Give the parameters to the call to {\tt find-fixpoint} and report the root found by your implementation.

    \begin{emph}
      Answer: % Implement and test, then report the results here.
    \end{emph}

  \end{enumerate}

\end{enumerate}

\end{document}